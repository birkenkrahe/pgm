#+STARTUP: overview hideblocks indent entitiespretty:
* 0 - Overview and Problem Solving

- [ ] Introduce [[https://open.kattis.com][open.kattis.com]]
- [ ] Solve and submit [[https://open.kattis.com/problems/hello][hello world problem]]
- [ ] Issues of competitive programming

* 1 - Warming up with counting ("Telja", "Ovissa")

- [X] Review week 0
- [X] Program of the week
- [X] Post-mortem

** Review Week 0

1. What's the main challenge of competitive programming?
   #+begin_quote
   Managing problem constraints (requirements).
   #+end_quote
2. What does "problem solving" mean to a [competitive] programmer?
   #+begin_quote
   Writing an *original* program that performs a set of tasks meeting
   all the stated *constraints*.
   #+end_quote
3. Which two issues are at the heart of all constraints?
   #+begin_quote
   - Time complexity (how long does the program take)
   - Space complexity (how much memory does the program need)
   #+end_quote
4. What's a "Kobayashi Maru" solution?
   #+begin_quote
   It's a solution that violates the constraints by cheating (bending
   the rules). It's a good start to solving a problem though.
   #+end_quote
5. How many problem solving process steps can you name?
   #+begin_quote
   |   | STEP                      | EXAMPLE                |
   |---+---------------------------+------------------------|
   | 1 | Always have a plan        | Pseudocode             |
   | 2 | Restate the problem       | Use your own words     |
   | 3 | Divide problem into steps | Input/Output/Decisions |
   | 4 | Start with what you know  | Simplest way first     |
   | 5 | Reduce the problem        | Separate tasks later   |
   | 6 | Look for analogies        |                        |
   | 7 | Experiment                |                        |
   | 8 | Don't get frustrated      |                        |
   #+end_quote

** Program of the week: Telja

Use any language you like. I've done this in C++ and in Python 3.

1) Go to [[https://open.kattis.com/problems/telja][open.kattis.com/problems/telja]]
2) Use pen and paper.
3) Restate the problem in your own words.
4) Write pseudocode first.
5) Write the program out on paper.
6) Put program in editor and test it on the sample input/output.
7) If program runs, submit to open.kattis.com.
8) Summarize what you learnt (if anything).
9) Let's discuss the experience.
10) I show you my "literate" solution.

** Rationale

1) Go to [[https://open.kattis.com/problems/telja][open.kattis.com/problems/telja]]

   - This platform seems to work well and it is not tied to any
     secondary causes (international competitions, job interviews
     etc.)

   - It's the site that the Arkansas competitions seem to use.

   - The main weakness is that there may be too many "simple" problems.

2) Use pen and paper.

   - This will show you what you really know.

   - What speaks against it is that your muscles have memory that you
     lose when writing by hand.

   - In my experience, a lot of time is lost dabbling and groping
     around in the dark when you start editing in the computer right
     away. This works best when you already know the solution and are
     just trying to remember it.

3) Restate the problem in your own words.

   - Crucial step to check your understanding of the problem.

   - You will find that you missed things or added things just
     because.

   - You have to abstract away unnecessary detail (just like in real
     life).

4) Write pseudocode first.

   - You can reuse pseudocode for comments.

   - You're building a bridge to the code but you can still change
     programming language.

   - Best way to experiment with different data types.

5) Write the program out on paper.

   - Commit. Don't use pencil and eraser.

   - Your paper version will show you "version history" for free.

   - You have probably killed fewer trees than if you had used a
     computer.

6) Put program in editor and test it on the sample input/output.

   - You can pick different development environments.

   - You should not write straight into open.kattis.com because it
     does not compile but compile and run test cases.

   - This is useful if you already have a working program.

7) If program runs, submit to open.kattis.com.

   - This will run a bunch of test cases

8) Summarize what you learnt (if anything).

   - Probe your mind for things you noticed along the way.

9) Let's discuss the experience.

   - Be competitive but not too competitive.

10) I show you my "literate" solution.

    - For what it's worth. Emacs + Org-mode.

** Telja - Solution in C

Code:
#+begin_src C++ :tangle ../src/telja.c :results output :exports both :main no :includes
  #include <stdio.h>
  int main(void)
  {
    int n;
    scanf("%d",&n);
    for(int i=0;i<n;i++)
      printf("%d\n",(i+1));
    return 0;
  }
#+end_src

Test:
#+begin_src bash :results output :exports both
  cd ../src
  gcc telja.c -o telja
  echo "5" | ./telja
#+end_src

#+RESULTS:
: 1
: 2
: 3
: 4
: 5

** Ovissa - Solution

#+begin_src C++ :main no :includes :results none
  // Gets a single line of input and prints the number of 'u' characters
  #include <iostream>

  int main()
  {
    std::string input;
    getline(std::cin, input);
    std::cout << input.size() << std::endl;
    return 0;
  }
#+end_src

* 2 - Building towards mastery with reversal ("Ofugsnuid").
** Review: Takeaways

Do you remember anything worth remembering from our last meeting?

** Program of the week: Öfugsnúið (Icelandic for "reversed")

Link: https://open.kattis.com/problems/ofugsnuid

Concepts:
- Reading values into an array/vector
- Iterating forwards and backwards
- Printing elements with correct formatting
- Speeding up I/O by decoupling stream operations

Solve the problem if you can, then let's discuss your approach, then I
will present my computational conflagrations.

Next week: More reversal!

* 3 - More reversal using ~algorithms~: [[https://open.kattis.com/problems/vidsnuningur]["Vidsnuningur"]]
#+attr_html: :width 400px :float nil:
[[../img/vidsnuningur.png]]

** Discussion: From Code to Concept?

- We could have some fun with "programming literacy".

- Ideas:
  1) Improve some terrible code.
  2) Interpret some complicated code.
  3) Read/comment each other's code.
  4) Reverse engineer a mystery function.


** Problem of the week: [[https://open.kattis.com/problems/vidsnuningur][Vidsnuningur]] (reversal)

- [X] Publish problem and review assignment.
- [X] Comment on submitting submission screenshots.
- [X] Comment on the importance of reflection.
- [X] Problem posted in Canvas for your screenshot.
- [X] My literate solution posted in GitHub.

* 4 - Mystery code (from code to concept)
#+attr_html: :width 400px :float nil:
[[../img/mystery.png]]

** Solve the mystery

- The =mystery= code:
  #+name: mystery
  #+begin_src C++ :main yes :includes <iostream> <cstdlib> <string> <fstream> <vector> :namespaces std :results output :exports both :noweb yes
    void mystery(int arr[], int n) {
      int left = 0;
      int right = n - 1;
      int swaps = (n % 2 == 0) ? (n / 2) : ((n - 1) / 2);

      for (int count = 0; count < swaps; count++) {
        int temp = 0;
        temp += arr[left];
        temp -= 0;
        arr[left] = arr[right] + 0;
        arr[right] = temp * 1;
        left = left + 1;
        right = right - 1;
      }
    }
  #+end_src

  #+RESULTS: mystery

- What does this function do?
  #+begin_quote
  The function reverses the array in place: After the call, =arr[i]=
  becomes the original =arr[n-1-i]= for all valid =i=.
  #+end_quote
  #+begin_src C++ :main no :includes :results output :exports both :noweb yes
    #include <iostream>
    using namespace std;

    <<mystery>>

    int main()
    {
      int a[5] {100, 200, 300, 400, 500};
      for (int element : a) cout << element << " ";
      mystery(a,5); cout << endl;
      for (int element : a) cout << element << " ";
      return 0;
    }
  #+end_src

  #+RESULTS:
  : 100 200 300 400 500
  : 500 400 300 200 100

- Which lines are doing the real work?
  #+begin_example C++
    void mystery(int arr[], int n) {
      int left = 0;
      int right = n - 1;
      int swaps = (n % 2 == 0) ? (n / 2) : ((n - 1) / 2);

      for (int count = 0; count < swaps; count++) {
        int temp = 0;

        // copy left element into temp
        temp += arr[left];
        temp -= 0;   // pointless operation

        // overwrite left element with right
        arr[left] = arr[right] + 0;  // unnecessary +0

        // overwrite right element with temp
        arr[right] = temp * 1;  // unnecessary *1

        // adjust indices in a roundabout way
        left = left + 1;
        right = right - 1;
      }
    }
  #+end_example

- Can you rewrite this in a shorter, clearer way?

- What would be a better function name?

- Show your solutions first! How did you approach this?

- What did you learn?

** Sample solution
#+attr_html: :width 400px :float nil:
[[../img/mystery.jpg]]

- Sample solution:
  #+name: reverseArray
  #+begin_src C++ :main yes :includes <iostream> <cstdlib> <string> <fstream> <vector> :namespaces std :results output :exports both :noweb yes
    // reverse integer array of n elements in place
    void reverseArray(int arr[], int n) {
      int left = 0;
      int right = n - 1;

      while (left < right)
        {
          int temp = arr[left];
          arr[left] = arr[right];
          arr[right] = temp;
          left++;
          right--;
        }
    }
  #+end_src

  Testing:
  #+begin_src C++ :main no :includes :results output :exports both :noweb yes
    #include <iostream>
    using namespace std;

    <<reverseArray>>

    int main()
    {
      int a[5] {100, 200, 300, 400, 500};
      for (int element : a) cout << element << " ";
      reverseArray(a,5); cout << endl;
      for (int element : a) cout << element << " ";
      return 0;
    }
  #+end_src

  #+RESULTS:
  : 100 200 300 400 500
  : 500 400 300 200 100

- Why ~while~ and not ~for~?
  + ~for~ is slightly tighter: loop initialization, condition, and
    updates are all in one line.
  + ~for~ avoids the need for separate variable declarations before the loop.
  + ~for~ is much harder to read (personal view).
  + ~while~ emphasizes logic (clarity of condition).
  + ~for~ emphasizes compact loop control.

- Code example:
  #+name: reverseArray2
  #+begin_src C++ :main yes :includes <iostream> <cstdlib> <string> <fstream> <vector> :namespaces std :results output :exports both :noweb yes
    // reverse integer array of n elements in place
    void reverseArray2(int arr[], int n) {
      for (int left=0,right=n-1; // start
           left < right;         // stop
           left++, right--)      // in/decrement
        {
          int temp = arr[left];
          arr[left] = arr[right];
          arr[right] = temp;
        }
    }
  #+end_src

  Testing:
  #+begin_src C++ :main no :includes :results output :exports both :noweb yes
    #include <iostream>
    using namespace std;

    <<reverseArray2>>

    int main()
    {
      int a[5] {100, 200, 300, 400, 500};
      for (int element : a) cout << element << " ";
      reverseArray2(a,5); cout << endl;
      for (int element : a) cout << element << " ";
      return 0;
    }
  #+end_src

  #+RESULTS:
  : 100 200 300 400 500
  : 500 400 300 200 100

- What did I learn?

  1) Needed to work through mystery code away from the code.

  2) Worth considering alternatives for loops and conditions.

  3) Think past arrays for performance optimization.

  4) Motivates me to check for more "mystery code" elsewhere.

  5) How to design unnecessarily confused and complicated code.

* 5 - [[https://open.kattis.com/problems/vectorfunctions][Vector functions]] (~vector~ class)
* 6 - [[https://open.kattis.com/problems/averagecharacter][Average character]] (~string~ class)
* 7 - Pointer to object and ~string~ stream
#+OPTIONS: toc:nil num:nil ^:nil: 

- New mystery file: tinyurl.com/player-cpp

- Introduces printing to a ~string~ stream (a form of
  overloading/polymorphism, for safe buffering).

- Uses a ~class~ reference ~return~ type and the ~this~ pointer to be able
  to keep working on an object (for chaining).

- Simplify the program:
  1) Remove references and pointers, make member functions "normal".
  2) Check if you need all functions, especially global ones.
  3) Remove the string stream and print the data as a normal string.

** Explanation of ~<sstream>~ and ~ostringstream~

The header ~<sstream>~ provides classes that let you read from and write
to strings as if they were input/output streams (like ~cin~ and ~cout~).

- ~ostringstream~ means "output string stream."  You can “print” text
  into it using the `<<` operator, just like ~cout~.  When you’re
  done, you can get the entire string using ~.str()~.

Example:
#+begin_src C++ :results output
  #include <sstream>
  #include <string>
  #include <iostream>
  using namespace std;

  int main() {
    ostringstream os; // string stream object
    os << "Score: " << 42 << ", Lives: " << 3; // print to string stream
    string info = os.str();  // get string data
    cout << info; // Output: Score: 42, Lives: 3
  }
#+end_src

#+RESULTS:
: Score: 42, Lives: 3

** Explanation of =Player= reference and ~this~ pointer

- Code fragment from the class review:
  #+begin_example C++
   Player& fire(int rounds) { // returns reference to same Player object
     ammo -= rounds;          // ammo is private Player data
     if (ammo < 0) ammo = 0;
     return *this;            // returns value of current Player object
   }
  #+end_example

- When member functions are defined in this way, they can be
  chain-called: =p.fire(10).reload(5).move(1,0)=. Each method works on
  ~this~ same object =p= without creating a copy.

** The ~this~ Pointer

Every non-static member function in C++ has an implicit pointer named
~this~, which points to the object that called the function.

- Inside a member function, you can use ~this~ to refer explicitly to the
  current object.

- When returning ~*this~, you return the object itself by reference,
  enabling method chaining.

- Example:
  #+begin_src C++ :results output
    #include <iostream>
    using namespace std;

    class Counter {
    private:
      int value;
    public:
      Counter(int v) : value(v) {}

      Counter& add(int n) {
        value += n;
        return *this;   // return reference to this object
      }

      Counter& sub(int n) {
        value -= n;
        return *this;
      }

      void show() const {
        cout << "Value = " << value << endl;
      }
    };

    int main() {
      Counter c(10);
      c.add(5).sub(3).add(2);  // chain-calling works via `this`
      c.show();                 // prints: Value = 14
    }
  #+end_src

- Here, ~this~ is a pointer to the object =c=. When =add()= and =sub()= return
  ~*this~, they return the same object, allowing the chain
  =c.add(5).sub(3).add(2)=.
