#+TITLE: C vs. C++ Strings
#+STARTUP: overview hideblocks indent entitiespretty:
#+OPTIONS: toc:nil num:nil ^:nil:
* From C-style strings to ~std::string~ (â‰ˆ30 min)

** Why this matters

- Manual =new[] / delete[]= + =strcpy= is error-prone (memory leaks,
  buffer overflows).

- =std::string= does the heavy lifting automatically and is the
  idiomatic C++ way.

** Original C-style version (for reference)

This code is available in GitHub: 
- tinyurl.com/contact-info-h: =ContactInfo.h= 
- tinyurl.com/contact-info-test-cpp: =ContactInfoTest.cpp=

#+begin_src C++ :tangle ../src/ContactInfo.h :main no :results none
  #ifndef CONTACTINFO_H
  #define CONTACTINFO_H
  #include <cstring>

  class ContactInfo {
  private:
    char *name;
    char *phone;
  public:
    ContactInfo(const char *n, const char *p) {
      name  = new char[strlen(n)+1];
      phone = new char[strlen(p)+1];
      strcpy(name,  n);
      strcpy(phone, p);
    }
    ~ContactInfo() { delete[] name; delete[] phone; }
    const char *getName()        const { return name; }
    const char *getPhoneNumber() const { return phone; }
  };
  #endif
#+end_src

** Test program

#+begin_src C++ :flags -I ../src :results output :exports both :tangle ../src/ContactInfoTest.cpp
  #include <iostream>
  #include "ContactInfo.h"          // you will rename this later
  using namespace std;

  int main() {
    ContactInfo entry("Kristen Lee", "555-2021");
    cout << "Name: " << entry.getName() << "\n"
         << "Phone Number: " << entry.getPhoneNumber() << "\n";
    return 0;
  }
#+end_src

#+RESULTS:
: Name: Kristen Lee
: Phone Number: 555-2021

** Task

- Get the files with =wget -O= and compile them with =g++=.
- Turn this C-style string program into a C++-style string program.
- Create a new header and test file.
- Remove all manual memory allocation and string manipulation.
- Keep public interface: Constructor takes two string-like arguments.
- Getter functions return a constant string reference (no copies).
- No destructors needed.
- Don't forget the header guards.

** Bonus task

Add a member function to =ContactInfo=:

#+begin_src C++ :eval no
  void setPhoneNumber(const std::string& newPhone);
#+end_src

** Destroying strings (Matthew's question)

What if I do want to destroy the string memory?

Three methods to do that:
#+begin_src C++ :main yes :includes <iostream> :results output :exports both :comments both :tangle yes :noweb yes
  std::string s = "In a galaxy far, far away...";
  s.clear();   // removes content but capacity remains
  s.shrink_to_fit();  // return unused memory

  // resetting a dynamic string
  std::string *ps = new std::string("dynamic string");
  delete ps; // release both object and the buffer

  // swap the string memory with the empty string
  std::string s2 = "A very, very long, boring story...";
  std::string empty;
  s2.swap(empty); // frees all memory - swaps with empty string
#+end_src

* Solution 

#+begin_src C++ :tangle ../src/ContactInfo2.h :main no :results none :exports none
  #ifndef CONTACTINFO2_H
  #define CONTACTINFO2_H
  #include <string>

  class ContactInfo {
  private:
    std::string name;
    std::string phone;
  public:
    ContactInfo(const std::string& n, const std::string& p)
      : name(n), phone(p) {}
    const std::string& getName()        const { return name; }
    const std::string& getPhoneNumber() const { return phone; }
  };
  #endif
#+end_src

#+begin_src C++ :flags -I ../src :results output :exports none
  #include <iostream>
  #include "ContactInfo2.h"
  using namespace std;

  int main() {
    ContactInfo entry("Kristen Lee", "555-2021");
    cout << "Name: " << entry.getName() << "\n"
         << "Phone Number: " << entry.getPhoneNumber() << "\n";
    return 0;
  }
#+end_src

#+RESULTS:
: Name: Kristen Lee
: Phone Number: 555-2021

* Follow-up: Mini-challenge (optional, 5 min)

Add a member function to =ContactInfo=:

#+begin_src C++ :eval no
  void setPhoneNumber(const std::string& newPhone);
#+end_src

Implement it in the header (inline). Then modify =main()= to change the
phone number and print again.

Answer:

#+begin_src C++ :exports none
  void setPhoneNumber(const std::string& newPhone) { phone = newPhone; }
#+end_src

#+begin_src C++ :flags -I ../src :results output :exports none
  #include <iostream>
  #include "ContactInfo2.h"
  using namespace std;

  int main() {
    ContactInfo entry("Kristen Lee", "555-2021");
    cout << "Original:\n";
    cout << "Name: " << entry.getName() << "\n"
         << "Phone: " << entry.getPhoneNumber() << "\n";
    entry.setPhoneNumber("999-8888");
    cout << "Updated:\n";
    cout << "Name: " << entry.getName() << "\n"
         << "Phone: " << entry.getPhoneNumber() << "\n";
    return 0;
  }
#+end_src

#+RESULTS:
: Original:
: Name: Kristen Lee
: Phone: 555-2021
: Updated:
: Name: Kristen Lee
: Phone: 999-8888

* Post-mortem: What a destructor actually does

The =Logger= class writes to =file=. The constructor opens a file. The
=write= function writes its =msg= to the file. The destructor =~Logger= only
closes the file.

#+begin_src C++ :main yes :includes <iostream> <cstdlib> <string> <fstream> <vector> :namespaces std :results output :exports both :noweb yes
  #include <iostream>
  #include <fstream>
  using namespace std;

  class Logger {
    ofstream file;

  public:
    Logger(const string& filename) {
      file.open(filename);
      if (file.is_open())
        cout << "Logger: File '" << filename << "' opened.\n";
      else
        cout << "Logger: Failed to open file!\n";
    }

    void write(const string& msg) {
      if (file.is_open())
        file << msg << endl;
    }

    ~Logger() {
      if (file.is_open()) {
        file.close();  // This is the key!
        cout << "Logger: File closed in destructor.\n";
      }
    }
  };

  int main() {
    {
      Logger log("output.txt");
      log.write("Hello from inside scope!");
    } // Scope ends here - now ~Logger runs automatically
    return 0;
  }
#+end_src

#+RESULTS:
: Logger: File 'output.txt' opened.
: Logger: File closed in destructor.

The destructor's job varies by memory/object type:

| Resource             | What happens if not cleaned up?    | Destructor's Job  |
|----------------------+------------------------------------+-------------------|
| Open file (~ofstream~) | File handle leak, data not flushed | ~file.close~        |
| Dynamic memory (~new~) | Memory leak                        | ~delete[] ptr;~     |
| Network socket       | Connection left open               | ~socket.close()~    |
| Database connection  | Connection pool exhausted          | ~conn.disconnect()~ |

* Summary (what I learnt)

- The destructor runs cleanup code (like closing files, connections).
- The system frees the memory - automatically for stack, manually for
  heap (you can trigger =~Logger= via ~delete Logger~.


