#+startup: overview hideblocks indent entitiespretty:
* Trivial problem 1.0 - [[https://open.kattis.com/problems/tilhamingju][Til hamingju (greeting)]]

- [[https://open.kattis.com/submissions/17743890][Kattis Submission]] (C++)

- Objectives: Using ~cout~, the ~ostream~ operator ~<<~, and string
  literals.

- Solution (C++):
  #+name: https://open.kattis.com/submissions/17743890
  #+begin_src C++
    #include <iostream>
    using std::cout;

    int main()
    {
      cout << "TIL HAMINGJU MED AFMAELID FORRITUNARKEPPNI FRAMHALDSSKOLANNA!" << "\n";
    }
  #+end_src

  #+RESULTS:

- Translation (ChatGPT) from the Icelandic:
  #+begin_quote
  "HAPPY BIRTHDAY HIGH SCHOOL PROGRAMMING COMPETITION!"
  #+end_quote

- Solution (Python):
  #+name: https://open.kattis.com/submissions/17759457
  #+begin_src python :tangle ../src/tilhamingju.py :results output :exports both :session *Python* :python python3
    print("TIL HAMINGJU MED AFMAELID FORRITUNARKEPPNI FRAMHALDSSKOLANNA!")
  #+end_src

  #+RESULTS:
  : TIL HAMINGJU MED AFMAELID FORRITUNARKEPPNI FRAMHALDSSKOLANNA!

* DONE Trivial problem 1.1 - [[https://open.kattis.com/problems/telja][Telja (to count)]]
** C++
- [[https://open.kattis.com/submissions/17744488][Kattis Submission]] (C++)

- Objectives: Using ~cin~ and ~>>~ for input, index loop, integer
  variables.

- Problem: Get a single positive integer =n= in [1,5] (Group 1), or
  [6,10000] (Group 2) as input from the user. Print all numbers from 1
  to =n=, one per line.

- Testing: the sample inputs are 2,3,5. Test these manually before
  submitting. Write the shell code for that (input file). Don't bother
  with screen dialog (it's not asked).

- Write the solution out on paper first. Enter it as written, then fix
  if necessary.

- Solution 1:
  #+begin_src C++ :tangle ../src/telja.cpp :main no :includes :results output
    #include <iostream>
    using std::cout;
    using std::cin;

    int main()
    {
      int n;
      cin >> n;
      for (int i=0;i<n;i++)
        cout << (i+1) << "\n";

      return 0;
    }
  #+end_src

  #+RESULTS:

- Sample test: (org-babel-tangle)
  #+begin_src bash :results output :exports both
    cd ../src
    g++ telja.cpp -o telja
    echo 2 | ./telja        # Sample input 1
  #+end_src

  #+RESULTS:
  : 1
  : 2

- Sample Input 2:
  #+begin_src bash :results output :exports both
    cd ../src; echo 3 | ./telja
  #+end_src

  #+RESULTS:
  : 1
  : 2
  : 3

- Sample Input 3:
  #+begin_src bash :results output :exports both
    cd ../src; echo 5 | ./telja
  #+end_src

  #+RESULTS:
  : 1
  : 2
  : 3
  : 4
  : 5

- Post mortem:

  1. On paper, forgot to use ~main~ (bad habit from using Org-mode).

  2. Ignored the constraints at first. Then realized that that's OK.

  3. Forgot to use the ~std~ namespaces for ~cout~ and ~cin~.

  4. Reformulated the problem with constraints and output - useful for
     a short problem like this.

- Results from open.kattis.com:
  #+attr_html: :width 400px :float nil:
  [[../img/kattis.png]]

** Python 3

- Input: a single integer n in [1,5] or [6,100000].
- Output: n lines containing the counts from 1 to n.

#+name: telja python3
#+begin_src python :tangle ../src/telja.py :results output :exports both :session *Python* :python python3
  n = int(input())
  for i in range(n):
      print(i+1)
#+end_src

#+RESULTS: telja python3
: 1
: 2
: 3
: 4
: 5

#+begin_src bash :results output :exports both
  cd ../src
  echo 5 | python3 telja.py
#+end_src

#+RESULTS:
: 1
: 2
: 3
: 4
: 5

** Fast solution in C

- For n in [1,9] only:
  #+begin_src C :tangle ../src/telja2.c :main no :includes :results output :exports both
    #include <stdio.h>
    int main()
    {
      int n;
      scanf("%d",&n);
      for (int i = 1; i <= n; i++) {
        putchar(i + '0');
        putchar('\n');
      }
      return 0;
    }
  #+end_src
- Test
  #+begin_src bash :results output :exports both
    cd ../src
    gcc telja2.c -o telja2
    echo "5" | ./telja2
  #+end_src
- Fast C++ version:
  #+begin_src C++ :tangle ../src/telja3.cpp :main no :includes :results output :exports both
    #include <bits/stdc++.h>
    using namespace std;

    inline void write_uint(int x) {
      char s[10]; int i = 0;
      do s[i++] = '0' + x % 10; while (x /= 10);
      while (i--) putchar_unlocked(s[i]);
      putchar_unlocked('\n');
    }

    int main() {
      ios::sync_with_stdio(false);
      cin.tie(nullptr);

      int n;
      cin >> n;
      for (int i = 1; i <= n; i++) write_uint(i);
    }
  #+end_src
- Test
  #+begin_src bash :results output :exports both
    cd ../src
    g++ telja3.cpp -o telja3
    echo "100000" | ./telja3 > output
    tail -n 5 output
  #+end_src

  #+RESULTS:
  : 99996
  : 99997
  : 99998
  : 99999
  : 100000

* DONE Trivial problem 1.1 - [[https://open.kattis.com/problems/ovissa][Ovissa (uncertainty)]]
#+OPTIONS: toc:nil num:nil ^:nil:
[[https://open.kattis.com/submissions/17744931][Kattis Submission]]

1. *Objectives:* ~string~ library and letting go of my original design
   completely. Strong reliance on cppreference.com for documentation.

2. *Problem restatement:* Write a C++ program that takes a string of =u=
   characters from the keyboard and prints the number of characters =n=.

3. Constraint: n in [1,5] (Group 1), or n in [1,100000] (Group 2) - no
   code is required to check these constraints.

4. Sample input/output:

   | Input          | Output |
   |----------------+--------|
   | uuuuu          |      5 |
   | uuuuuuuuuuuuuu |     14 |

5. Approach: This problem includes a conversion of character input to
   integer output. The conversion is explicit through counting the
   number of characters. The program can get the characters in a
   ~do-while~ loop that's over as soon as an empty character (~\0~) is
   entered.

6. I'm going to do this as pseudocode first, then I'll test the I/O,
   then I'll write the full program.

7. Pseudocode
   #+begin_example
   SET u counter to 0
   DO
       GET input
       if input == 'u'
          counter++
   WHILE input
   PRINT counter
   #+end_example

8. I/O test program =io.cpp= (test on shell):
   #+begin_src C++ :tangle ../src/io.cpp :main yes :includes <iostream> :namespaces std :results none
     // gets and prints character input in a loop
     // the loop ends when there is no more input
     char input;
     do
       {
         cin >> input;
         cout << "-->" << input << endl;
       } while (input != '\0');
   #+end_src

9. =io.cpp= takes input and prints it but it does not terminate when an
   empty character ~'\0'~ is entered. Let's try =getline(cin,input)= for
   =io2.cpp= ([[https://en.cppreference.com/w/cpp/string/basic_string/getline][cppref]]):
   #+begin_src C++ :tangle ../src/io2.cpp :main yes :includes <iostream> <string> :namespaces std :results none
     // gets and prints character input in a loop
     // the loop ends when there is no more input
     char input;
     do
       {
         getline(cin, input);
         cout << "-->" << input << endl;
       } while (input);
   #+end_src

10. I cannot even get this to compile: The =input= argument needs to be a
    ~string~! Version 3, =io3.cpp=:
    #+begin_src C++ :tangle ../src/io3.cpp :main yes :includes <iostream> <string> :namespaces std :results none
      // gets and prints character input in a loop
      // the loop ends when there is no more input
      string input;
      do
        {
          getline(cin, input);
          cout << "-->" << input << endl;
        } while (input);
    #+end_src

11. Another compilation error: Now the termination condition
    =while(input)= does not work because ~string~ cannot be converted
    automatically to ~bool~! I am learning a lot from this silly problem!

12. Checking cppref for the [[https://cppreference.com/w/c/language/do.html][do-while loop]]. The ~while~ expression needs to
    be a scalar, but =input= is a ~string~ (therefore an array).

13. Modifying the expression to: ~input != '\0'~ in =io4.cpp=:
    #+begin_src C++ :tangle ../src/io4.cpp :main yes :includes <iostream> <string> :namespaces std :results none
      // gets and prints character input in a loop
      // the loop ends when there is no more input
      string input;
      do
        {
          getline(cin, input);
          cout << "-->" << input << endl;
        } while (!input.empty());
    #+end_src

14. Okay, now this works alright and it satisfies the rules because the
    input must "consist of a single line", like "uuuuu". Let's add the
    counter, =ovissa=.

15. This causes another problem - we need to *count* the number of =u=
    characters in the input. We assume only the sample input from the
    tests. Let's try the ~string::size()~ function.

    But also, we no longer need the ~do-while~ loop or the counter
    variable =ovissa= since all the heavy lifting is done by
    ~std::basic_string~ functions.

    I tried to change the type of =input= to ~const string~ but that does
    not work since =input= is being built from the keyboard input
    stream, I suppose.

    #+begin_src C++ :tangle ../src/io5.cpp :main yes :includes <iostream> <string> :namespaces std :results none
      // Gets a single line of input and prints the number of 'u' characters
      string input;
      getline(cin, input);
      cout << input.size() << endl;
    #+end_src

16. Works - I'm going to submit (after adding the wrapper):
    #+begin_src C++ :main no :includes :results none
      // Gets a single line of input and prints the number of 'u' characters
      #include <iostream>
      using namespace std;

      int main()
      {
        string input;
        getline(cin, input);
        cout << input.size() << endl;
        return 0;
      }
    #+end_src

17. Here's another solution, with ~.size()~
    #+begin_src C++ :tangle ../src/io6.cpp :main no :includes :results none
      // Gets a single line of input and prints the number of 'u' characters
      #include <iostream>
      #include <string>
      using namespace std;

      int main()
      {
        string input;
        cin >> input;
        cout << input.size() << endl;
        return 0;
      }
    #+end_src

18. In fact, ~cin~ achieves the same thing here as ~getline~ but it's
    simpler and suffices because we don't anticipate any other
    characters than u's, and no whitespaces. ~getline~ is safer (it
    says).

19. Discuss the relative merits of ~std::cin~ (an instance of the
    ~istream~ class, which see whitespace as a delimiter) vs
    ~std::getline~ (a member function of the ~string~ class - meant for
    multi-word input). ~cin~ can also lead to an input buffer overflow
    (and a consequential security vulnerability). ~getline~ has an
    optional parameter to cap input length and prevent overflow).

    Source: [[https://expertbeacon.com/getline-in-c-an-in-depth-guide-to-cin-getline/][expertbeacon.com (08/2024)]]

    | Feature                      | std::cin >> var   | std::getline(cin,var)  |
    |------------------------------+-------------------+------------------------|
    | Reads up to whitespace       | Yes               | No (reads entire line) |
    | Multi-word strings           | No                | Yes                    |
    | Handles leading whitespace   | Skips it          | Preserves it           |
    | Stops reading at:            | First whitespace  | Newline (`\n`)         |
    | Use case                     | Single word/token | Full-line input        |
    | Reads newline character?     | No                | Yes (and discards it)  |
    | Risk of leaving \n in buffer | No                | No                     |
    | Simplicity for token input   | Simpler           | Slightly more overhead |

** Ovissa in Python

#+begin_src python :tangle ../src/ovissa.py
  s = input().strip()
  uncertainty_level = s.count('u')
  print(uncertainty_level)
#+end_src

** Ovissa in C

Tickled by Matthew's "Fastest Solution" trophy. Trying this in C:

* DONE Trivial problem 1.1 - [[https://open.kattis.com/problems/vidsnuningur][Vidsnuningur (reversal)]]

** Problem
- Not necessarily "trivial". I tried two things:
  1) with the ~reverse~ function from ~<algorithm>~ (requires iterators)
  2) without ~<string>~ but instead with C-style strings and ~<cstring>~
     and manual reversal in a reverse ~for~ loop.

- Problem: Take a string of letters and digits without whitespace as
  input and print the reverse string as output.

- Constraints: Input should be one line containing 1 to 1000 English
  letters and digits. There's no need to check the limit in the code.

- Testing:
  #+begin_example
  Input: 2202annaloksdlahmarfinppekranutirroF
  Output: Forritunarkeppniframhaldskolanna2022

  Input: amma
  Output: amma
  #+end_example

- Plan:
  1) use ~cin~ and ~std::reverse~ from ~<algorithm>~.
  2) code problem manually.

     With ~reverse~:
     #+begin_example
     Stream input with cin
     Print std::input.reverse(string, first=0, last=length())
     #+end_example

** ~std::reverse~

- Test use of ~reverse~ for a string.
  1) Define a start and an end iterator.
  2) Use them as arguments.
  #+begin_src C++ :main yes :includes <algorithm> <iostream> <cstdlib> <string> <fstream> <vector> :namespaces std :results output :exports both :noweb yes
    string s = "Hello";
    string::iterator a = s.begin();
    auto b = s.end()-1;
    cout << *a << endl;
    cout << *b << endl;
    reverse(s.begin(),s.end()); // reverses in place!
    cout << s;
  #+end_src

  #+RESULTS:
  : H
  : o
  : olleH

- Solution 1: with ~reverse~
  #+begin_src C++ :tangle ../src/reversal.cpp :main yes :includes <algorithm> <iostream> <cstdlib> <string> <fstream> <vector> :namespaces std :results output :exports both :noweb yes
    string str;
    cin >> str;
    reverse(str.begin(), str.end());
    cout << str;
  #+end_src

  #+RESULTS:

- Testing the solution: (org-babel-tangle)
  #+begin_src bash :results output :exports both
    cd ../src
    make reversal
  #+end_src

  #+RESULTS:
  : g++     reversal.cpp   -o reversal

  #+begin_src bash :results output :exports both
    cd ../src
    echo "2202annaloksdlahmarfinppekranutirroF" | ./reversal
    echo
    echo "amma" | ./reversal
  #+end_src

  #+RESULTS:
  : Forritunarkeppniframhaldskolanna2022
  : amma

- [[https://open.kattis.com/submissions/17747785][Submission 1:]] OK
  #+begin_src C++ :main no :includes :tangle ../src/vidsnuningur.cpp :results none
    #include <iostream>
    #include <string>
    #include <algorithm>

    int main()
    {
      std::string str;
      std::cin >> str;
      reverse(str.begin(), str.end());
      std::cout << str;

      return 0;
    }
  #+end_src

** Manual reverse

- Plan: Step through the string from the end and print each character.

- Stepping through a string:
  #+begin_src C++ :main yes :includes <algorithm> <iostream> <cstdlib> <string> <fstream> <vector> :namespaces std :results output :exports both
    string str = "Hello";

    for (char chr : str)
      cout << chr; // original string

    cout << "\n" << str.length() << endl;

    for (int i = 0; i < str.length(); i++)
      cout << str[i]; // original string

    cout << endl;

    for (int i = str.length()-1; i >= 0; i--)
      cout << str[i];
  #+end_src

  #+RESULTS:
  : Hello
  : 5
  : Hello
  : olleH

- Let's use ~gdb~ to find the error here:
  #+begin_src C++ :tangle ../src/rev.cpp :main no :includes :results none
    #include <iostream>
    #include <string>

    int main()
    {
      std::string str = "Hello";
      for (int i = str.length()-1; i == 0; i--)
        std::cout << str[i];

      return 0;
    }
  #+end_src

  1) Compile with =-g= options: =g++ -g rev.cpp -o rev=
  2) Enter debugger with =gdb rev=
  3) In (gdb) console:
     - =list= (list file with line numbers)
     - =break 7= (line number for break stop)
     - =run= (run up to =break= line number)
     - =step= (next step)
  4) Turns out that the loop is never entered because the condition
     i==0 is malformatted: it is only satisfied when i is 0 but at the
     start it is i = 4.
  5) Correction: Change to i >= 0;

- Even more C-style without ~string~ but with ~char []~ instead:
  #+begin_src C++ :main no :includes :results output
    #include <iostream>

    int main()
    {
      char str[] = "2202annaloksdlahmarfinppekranutirroF";
      int size = sizeof(str);
      for (int i = size-2; i >= 0; i--)
        std::cout << str[i];

      return 0;
    }
  #+end_src

  #+RESULTS:
  : Forritunarkeppniframhaldskolanna2022

- Submission 2: does not compile at kattis.com!  Reason: ~cin~ cannot
  stream into an uninitialized pointer-to-char. You need either a
  C-style array like =char str[1000];= or use ~string~.

  #+begin_src C++ :main no :includes :noeval :tangle ../src/rev2.cpp
    #include <iostream>

    int main()
    {
      char *str = nullptr;
      std::cin >> str;
      int size = sizeof(str);
      for (int i = size-2; i >= 0; i--)

        std::cout << str[i];

      return 0;
    }
  #+end_src

  Segmentation fault!
  #+begin_src bash :results output :exports both
    cd ../src
    g++ rev2.cpp -o rev2
    echo "2202annaloksdlahmarfinppekranutirroF" | ./rev2
    echo
    echo "amma" | ./rev2
  #+end_src

- Corrected submission 2:
  #+begin_src C++ :main no :includes :tangle ../src/rev3.cpp :results output
    #include <iostream>

    int main()
    {
      char str[1000];
      for (int i=0; i<1000; i++)
        {
          scanf("%c",&str[i]);
          printf("%c ", str[i]);
        }
      return 0;
    }
  #+end_src

  Testing
  #+begin_src bash :results output :exports both
    cd ../src
    g++ rev3.cpp -o rev3
    ##echo "2202annaloksdlahmarfinppekranutirroF" | ./rev3
    ##echo
    ##echo "amma" | ./rev3
    echo "Hello" | ./rev3
  #+end_src

  #+RESULTS:
  : H e l l o
  :              § u                             § u     ÿ ÿ ÿ ÿ         Ê                ) q > § u     ð Ê t > § u                       ­ b > § u       ­ b > § u     €      ÿ ÿ     È  b > § u     Ê                                            € ¦ p > § u     ¸ ¡ ! > § u     É ± ì          æ Y     ˆ Ý ì     æ Y     @ À t > § u     q O r > § u                                     ) q > § u     ` Ö r > § u                     À $ ™ Ä ý                     H % ™ Ä ý      É ± ì       æ Y     ® } r > § u                     ˆ Ý ì     æ Y     @                ¿ ! > § u     à Ò t > § u     P À ! > § u                   ˜ 3 b > § u     ø 3 b > § u                       ™ b > § u     €      ÿ ÿ                                                                                                                                                                                                                                                                      à ì         æ Y      à ì       æ Y      à ì       æ Y                      à ì       æ Y      à ì       æ Y     Ð 3 b > § u     ø 3 b > § u     p 3 b > § u     ˜ 3 b > § u     p 3 b > § u     ˜ 3 b > § u     ø 3 b > § u                     Ð 3 b > § u     ø 3 b > § u                                                                                                                                                                                                                                                                         b > § u       ­ b > § u       ™ b > § u     ` ž b > § u     à  b > § u     à ž b > § u     À Ÿ b > § u       " L > § u     à ž b > § u     à  b > § u     ` ž b > § u     à š b > § u                                 €                                                                                                                   ä š  µ ù ¹ Æ à ¬ ! > § u     § # L > § u     ˆ Ž b > § u     ˆ Ž b > § u     ˆ Ž b > § u         U > § u     X  b > § u     ê ç Q > § u     È  b > § u     ˆ Ž b > § u     @ ‰ b > § u    

- String instead of character: Need to find out when the entered
  string stops!
  #+begin_src C++ :main no :includes :tangle ../src/rev4.cpp :results output
    #include <iostream>

    int main()
    {
      char str[1000];
      int count=0;
      scanf("%s",str);
      std::cout << str;
      for (int i=0; i<1000;i++)
        {
          if (str[i] == '\0')
        {
          std::cout << "\n" << i;
          break;
        }
          count++;
        }
      std::cout << count << "\n";
      for (int i=count-1; i>=0; i--)
        std::cout << str[i];
      return 0;
    }
  #+end_src

  #+RESULTS:

  Testing:
  #+begin_src bash :results output :exports both
    cd ../src
    g++ rev4.cpp -o rev4
    echo "Hello" | ./rev4
  #+end_src

  #+RESULTS:
  : Hello
  : 55
  : olleH

- [[https://open.kattis.com/submissions/17748022][Submission 2: OK]]

  With ~#include <cstring>~ and =strlen(str)=.

  #+begin_src C++ :main no :includes :noeval :tangle ../src/rev5.cpp
    #include <iostream>
    #include <cstring>

    int main()
    {
      char str[1000];
      std::cin >> str;
      int size = strlen(str);
      for (int i = size-1; i >= 0; i--)
        std::cout << str[i];
      return 0;
    }
  #+end_src

  Testing:
  #+begin_src bash :results output :exports both
    cd ../src
    g++ rev5.cpp -o rev5
    echo "Hello" | ./rev5
  #+end_src

  #+RESULTS:
  : olleH

** Using range-based loop and read from file

These are two things we did in the CSC 240 class today: range-based
~for~ loops and reading from files using ~ifstream~.

Input data: just using "Hello" for reversal.
#+begin_src bash :results output
  echo "Hello" > ../data/iFile.txt
  cat ../data/iFile.txt
#+end_src

#+RESULTS:
: Hello

The code (with comments): We're using =std::rbegin= and =std::rend=
(introduced in C++14 and later). This treats arrays as ranges in
~<iterator>~
#+begin_src C++ :tangle ../src/rev6.cpp :main no :includes :results none :exports both
  #include <iostream>
  #include <iterator>
  #include <fstream>  // include file stream

  int main()
  {
    std::string str;
    std::ifstream iFile;  // data come from the file iFile
    iFile.open("../data/iFile.txt");
    if (!iFile) {std::cerr << "file open failed\n"; return 1;}
    iFile >> str;
    iFile.close();
    // iterate forward over the reversed string:
    for (auto it=std::rbegin(str); it != std::rend(str); ++it)
      {
        std::cout << *it << " "; // print dereferenced iterator
      }
    return 0;
  }
#+end_src

Testing:
#+begin_src bash :results output
  cd ../src
  g++ rev6.cpp -o rev6
  ./rev6
#+end_src

#+RESULTS:
: o l l e H

** Using range-based loop reading from stdin

*Submission 3:*
#+name: https://open.kattis.com/submissions/18099374
#+begin_src C++ :tangle ../src/rev7.cpp :main no :includes :results none :exports both
  #include <iostream>
  #include <iterator>

  int main()
  {
    std::string str;
    std::cin >> str;
    for (auto it=std::rbegin(str); it != std::rend(str); ++it)
      {
        std::cout << *it;
      }
    return 0;
  }
#+end_src

#+begin_src bash :results output
  cd ../src
  g++ rev7.cpp -o rev7
  echo "2202annaloksdlahmarfinppekranutirroF" | ./rev7
  echo
  echo "amma" | ./rev7
#+end_src

#+RESULTS:
: Forritunarkeppniframhaldskolanna2022
: amma

* Easy problem 1.2 - [[https://open.kattis.com/problems/takkar][Takkar (buttons)]]

- [[https://open.kattis.com/submissions/17744704][Kattis Submission]]

- Objectives: Parallel conditional statements, input and output.

- This program takes two integers =a=, =b=, from the user and prints one
  of three messages depending on their relationship:
  1. If =a < b= then print =FAKE NEWS!=
  2. If =a = b= then print =WORLD WAR 3!=
  3. If =a > b= then print =MAGA!=

- Constraints: a,b should be in [0,10^9]. But this does not need to be
  coded (it's not checked by the tests).

- Sample input and output:

  |    a |    b | out          |
  |------+------+--------------|
  |    7 |   13 | FAKE NEWS!   |
  | 1337 | 1337 | WORLD WAR 3! |
  |  420 |   42 | MAGA!        |

- Solution:
  #+begin_src C++ :tangle ../src/takkar.cpp :main no :includes
    #include <iostream>
    using std::cin;
    using std::cout;
    int main()
    {
      int a,b;
      cin >> a >> b;
      if (a < b)
        cout << "FAKE NEWS!";
      else if (a > b)
        cout << "MAGA!";
      else // a == b
        cout << "WORLD WAR 3!";
      return 0;
    }
  #+end_src

  #+RESULTS:
  : MAGA!

- Testing: (org-babel-tangle)
  #+begin_src bash :results output :exports both
    cd ../src
    make takkar
    echo 7 13 | ./takkar
  #+end_src

  #+RESULTS:
  : make: 'takkar' is up to date.
  : FAKE NEWS!

- Sample case 2
  #+begin_src bash :results output :exports both
    cd ../src
    echo 1337 1337 | ./takkar
  #+end_src

  #+RESULTS:
  : WORLD WAR 3!

- Sample case 3
  #+begin_src bash :results output :exports both
    cd ../src
    echo 420 42 | ./takkar
  #+end_src

  #+RESULTS:
  : MAGA!

* Easy problem 1.2 - [[https://open.kattis.com/problems/aldur][Aldur (age)]]

- Use ~std::vector~ and ~min_element~ from ~algorithm~, or use dynamical
  memory allocation (or smart pointers) with an array and manual
  finding of the minimum in a loop.

- Problem: Get the length of an array as input =n=, followed
  by =n= integers. Print the smallest of these =n= integers.

- Constraints (no need to code): =n= in [0,1000], and the following
  integers in [0,10000].

- Testing:
  1) n = 5 followed by 5,3,4,1,2 prints 1.
  2) n = 4 followed by 3,3,3,100 prints 3.

- Approach: The solution consists of three parts
  1. Store input in dynamically allocated array of length n.
  2. Find the minimum among the elements of the array.

- With ~vector~, dynamical allocation is automatic.

- Store input as vector:
  #+name: aldur
  #+begin_src C++ :tangle ../src/aldur.cpp :main no :includes :results output :exports both
    #include <iostream>
    #include <vector>
    #include <algorithm>
    using namespace std;

    int main()
    {
      int friends, tmp;
      vector<int> ages;

      cin >> friends;
      cout << friends << " ";
      for (int i=0; i<friends; i++)
        {
          cin >> tmp;
          ages.push_back(tmp);
        }

      for (int age : ages)
        cout << age << " ";

      return 0;
    }
  #+end_src

  #+RESULTS: aldur
  : -368303193

- Testing
  #+begin_src bash :results output :exports both
    cd ../src
    g++ aldur.cpp -o aldur
    echo "4 3 3 3 100" | ./aldur
    echo
    echo "5 5 3 4 1 2" | ./aldur
  #+end_src

  #+RESULTS:
  : 4 3 3 3 100
  : 5 5 3 4 1 2

- Find ~min_element~ in ~vector~:
  #+begin_example
  std::vector<int> v;
  std::vector<int>::iterator result = std::min_element(v.begin(),v.end());
  #+end_example

- Use it:
  #+begin_src C++ :tangle ../src/aldur2.cpp :main no :includes :results output :exports both
    #include <iostream>
    #include <vector>
    #include <algorithm>

    int main()
    {
      int friends, tmp;
      std::vector<int> ages;
      for (int i=0; i<friends; i++)
        {
          std::cin >> tmp;
          ages.push_back(tmp);
        }
      std::vector<int>::iterator result = min_element(ages.begin(),ages.end());
      std::cout << *result;
      return 0;
    }
  #+end_src

  #+RESULTS:
  : 28782

- Testing
  #+begin_src bash :results output :exports both
    cd ../src
    g++ aldur2.cpp -o aldur2
    echo "4 3 3 3 100" | ./aldur2
    echo
    echo "5 5 3 4 1 2" | ./aldur2
  #+end_src

  #+RESULTS:
  : 3
  : 1

- Submission with =using namespace std;= and =auto=:
  #+begin_src C++ :main no :includes :tangle ../src/aldur3.cpp
    #include <iostream>
    #include <vector>
    #include <algorithm>
    using namespace std;

    int main()
    {
      int friends, tmp;
      vector<int> ages;
      for (int i=0; i<friends; i++)
        {
          cin >> tmp;
          ages.push_back(tmp);
        }
      auto result = min_element(ages.begin(),ages.end());
      cout << *result;
      return 0;
    }
  #+end_src

  #+RESULTS:
  : 32379

- Testing
  #+begin_src bash :results output :exports both
    cd ../src
    g++ aldur3.cpp -o aldur3
    echo "4 3 3 3 100" | ./aldur3
    echo
    echo "5 5 3 4 1 2" | ./aldur3
  #+end_src

  #+RESULTS:
  : 3
  : 1

- The first submission =aldur3.cpp= incurs a run-time error! I have
  stored the number of =friends= alongside the =ages= of the friends in
  the same vector. And (that's the error) I have never initialized
  =friends=. This number was supposed to be given on a line of its own -
  but that does not make a difference to the program (I think).

- Correction: [[https://open.kattis.com/submissions/17748130][Submission 1 OK]]
  #+begin_src C++ :main no :includes :tangle ../src/aldur4.cpp
    #include <iostream>
    #include <vector>
    #include <algorithm>
    using namespace std;

    int main()
    {
      int friends=0, tmp;
      vector<int> ages;
      cin >> friends;
      for (int i=0; i<friends; i++)
        {
          cin >> tmp;
          ages.push_back(tmp);
        }
      auto result = min_element(ages.begin(),ages.end());
      cout << *result;
      return 0;
    }
  #+end_src

- Testing
  #+begin_src bash :results output :exports both
    cd ../src
    g++ aldur4.cpp -o aldur4
    echo "4 3 3 3 100" | ./aldur4
    echo
    echo "5 5 3 4 1 2" | ./aldur4
  #+end_src

  #+RESULTS:
  : 3
  : 1

** With dynamical memory allocation (DMA)

- This is an exercise in remembering ~new~ and ~delete~ for arrays, and/or
  smart pointers. I can't remember the latter so I'm going to try the
  former first.

- Remembering how that works:
  #+begin_src C++ :main yes :includes <iostream> <cstdlib> <string> <fstream> <vector> :namespaces std :results output :exports both :noweb yes
    // Create a pointer-to-type of the type of variable you have
    int *arr = nullptr;

    // Specify a size later to get as input
    int size;

    // Make an array of length `size` from that pointer
    arr = new int[size];

    // Get the size as input (here simulated)
    size = 5;

    // Initialize array
    for (int i=0; i < size; i++)
      {
        (*(arr + i)) = 1;
        cout << *(arr + i) << " ";
      }
  #+end_src

  #+RESULTS:
  : 1 1 1 1 1

- Made an important mistake in the first version (but the compiler did
  not complain - only when it used some random negative value): I got
  =size= after allocating the array! It needs to be defined before!
  Correction:

  #+begin_src C++ :main yes :includes <iostream> <cstdlib> <string> <fstream> <vector> :namespaces std :results output :exports both :noweb yes
    // Create a pointer-to-type of the type of variable you have
    int *arr = nullptr;

    // Specify a size later to get as input
    int size;

    // Get the size as input (here simulated)
    size = 5;

    // Make an array of length `size` from that pointer
    arr = new int[size];

    // Initialize array
    for (int i=0; i < size; i++)
      {
        (*(arr + i)) = 1;
        cout << *(arr + i) << " ";
      }
  #+end_src

  #+RESULTS:
  : 1 1 1 1 1

- Include streaming data via ~cin~:
  #+begin_src C++ :tangle ../src/aldur5.cpp :main yes :includes <iostream> :namespaces std :results output :exports both
    // Create a pointer-to-type of the type of variable you have
    int *arr = nullptr;

    // Specify a size later to get as input
    int size;

    // Get the size as input
    cin >> size;

    // Make an array of length `size` from that pointer
    arr = new int[size];

    // Initialize array
    for (int i=0; i < size; i++)
      {
        cin >> (*(arr + i));
        cout << *(arr + i) << " ";
      }
  #+end_src

  #+RESULTS:
  : 0 0 0 0 0

- Testing this:
  #+begin_src bash :results output :exports both
    cd ../src
    g++ aldur5.cpp -o aldur5
    echo "4 3 3 3 100" | ./aldur5
  #+end_src

  #+RESULTS:
  : 3 3 3 100

- Now add a manual min check, just for fun, and to avoid ~<algorithm>~:
  #+begin_src C++ :tangle ../src/aldur6.cpp :main yes :includes <iostream> :namespaces std :results output :exports both
    // Create a pointer-to-type of the type of variable you have
    int *arr = nullptr;

    // Specify a size later to get as input
    int size;

    // Get the size as input
    cin >> size;

    // Make an array of length `size` from that pointer
    arr = new int[size];

    // Initialize array
    for (int i=0; i < size; i++)
      {
        cin >> (*(arr + i));
        //cout << *(arr + i) << " ";
      }

    // Find the smallest value among the array elements
    int min = *arr;
    for (int i = 0; i < size; i++)
      {
        if (*(arr + i) < min) min = *(arr + i);
      }
    // Print smallest value
    cout << min;
  #+end_src

  #+RESULTS:

- Testing this:
  #+begin_src bash :results output :exports both
    cd ../src
    g++ aldur6.cpp -o aldur6
    echo "4 3 3 3 100" | ./aldur6
    echo
    echo "5 5 3 4 1 2" | ./aldur6
  #+end_src

  #+RESULTS:
  : 3
  : 1

- [[https://open.kattis.com/submissions/17748629][Submission 3: OK]] - Forgot to ~delete~ the allocated memory at first!

  #+begin_src C++ :main no :includes :results none :tangle ../src/aldur7.cpp
    #include <iostream>
    using namespace std;

    int main()
    {
      // Create a pointer-to-type of the type of variable you have
      int *arr = nullptr;

      // Specify a size later to get as input
      int size;

      // Get the size as input
      cin >> size;

      // Make an array of length `size` from that pointer
      arr = new int[size];

      // Initialize array
      for (int i=0; i < size; i++)
        {
          cin >> (*(arr + i));
          //cout << *(arr + i) << " ";
        }

      // Find the smallest value among the array elements
      int min = *arr;
      for (int i = 1; i < size; i++)
        {
          if (*(arr + i) < min) min = *(arr + i);
        }
      // Print smallest value
      cout << min;

      delete [] arr;
      arr = nullptr;

      return 0;
    }
  #+end_src

- Testing this:
  #+begin_src bash :results output :exports both
    cd ../src
    g++ aldur7.cpp -o aldur7
    echo "4 3 3 3 100" | ./aldur7
    echo
    echo "5 5 3 4 1 2" | ./aldur7
  #+end_src

  #+RESULTS:
  : 3
  : 1

** With smart pointers

- The ~unique_ptr~ type is automatically deleted when it goes out of
  scope. The changes are minimal, only in the declaration and removal
  of the ~delete~ and repointing at the end. I changed from pointer
  notation back to index notation (as in the lecture example).

- [[https://open.kattis.com/submissions/17748631][Submission 4: OK]]
  #+begin_src C++ :main no :includes :results none :tangle ../src/aldur8.cpp
    #include <iostream>
    #include <memory>
    using namespace std;

    int main()
    {
      // Specify a size later to get as input
      int size;

      // Get the size as input
      cin >> size;

      // Create a smart pointer-to-type of the type of variable you have
      unique_ptr<int[]> ptr(new int[size]);

      // Initialize array
      for (int i=0; i < size; i++)
        {
          cin >> ptr[i];
        }

      // Find the smallest value among the array elements
      int min = ptr[0];
      for (int i = 1; i < size; i++)
        {
          if (ptr[i] < min) min = ptr[i];
        }
      // Print smallest value
      cout << min;

      return 0;
    }
  #+end_src

- Testing this:
  #+begin_src bash :results output :exports both
    cd ../src
    g++ aldur8.cpp -o aldur8
    echo "4 3 3 3 100" | ./aldur8
    echo
    echo "5 5 3 4 1 2" | ./aldur8
  #+end_src

  #+RESULTS:
  : 3
  : 1

* DONE Easy problem 1.3 - [[https://open.kattis.com/problems/ofugsnuid][Ofugsnuid (reversed)]]

- *Problem*: Reverse a list of =n= integers. The number =n= and each of the
  integers of the list are entered each on their own line.

- *Constraints:* Four groups for different ranges of =n=:
  1. n = 1
  2. n \in [1,5]
  3. n \in [1,1000]
  4. n \in [1,20000]

- *Sample Input/Output:*
  #+begin_example
   Input  Output |  Input Output
       5       5 |      3      9
       1       4 |     10     12
       2       3 |     12     10
       3       2 |      9
       4       1 |
       5         |
  #+end_example

- Approach:
  1) Use an dynamically allocated array =num= of ~size~ =n=.
  2) Step through the array in reverse index order.

- Alternative:
  1) Use a ~vector~ of ~size~ =n=.
  2) Define a reverse iterator for the print loop.

- Here, the pointer notation is actually quite natural since the array
  was defined as a pointer!

  #+begin_src C++ :tangle ../src/ofugsnuid.cpp :main yes :includes <iostream> :namespaces std :results none
    int n;
    cin >> n; // user input: length of list
    cout << "n = " << n << endl;

    int *arr = new int[n]; // new array of n elements
    for (int i=0; i<n; i++)
      {
        cin >> *(arr + i); // store integer list in arr
        cout << *(arr + i) << " ";
      }
    cout << endl;
    for (int i=n-1; i>=0; i--)
      {
        cout << arr[i] << " ";  // print integers in reverse
      }
    delete [] arr;
    arr = nullptr;
  #+end_src

- Testing with sample I/O:
  #+begin_src bash :results output :exports both
    cd ../src
    g++ ofugsnuid.cpp -o rev
    echo "3 10 12 9" | ./rev
    echo
    echo "5 1 2 3 4 5" | ./rev
  #+end_src

  #+RESULTS:
  : n = 3
  : 10 12 9
  : 9 12 10
  : n = 5
  : 1 2 3 4 5
  : 5 4 3 2 1

- Submission: OK
  #+name: https://open.kattis.com/submissions/17759691
  #+begin_src C++ :tangle ../src/ofugsnuid2.cpp :main yes :includes <iostream> :namespaces std :results none
    int n;
    cin >> n; // user input: length of list

    int *arr = new int[n]; // new array of n elements
    for (int i=0; i<n; i++)
      cin >> *(arr + i); // store integer list in arr
    cout << endl;
    for (int i=n-1; i>=0; i--)
      cout << arr[i] << " ";  // print integers in reverse
    delete [] arr;
    arr = nullptr;
  #+end_src

- Testing:
  #+begin_src bash :results output :exports both
    cd ../src
    g++ ofugsnuid2.cpp -o rev
    echo "3 10 12 9" | ./rev
    echo
    echo "5 1 2 3 4 5" | ./rev
  #+end_src

  #+RESULTS:
  :
  : 9 12 10
  :
  : 5 4 3 2 1

** ChatGPT-5 - fancy!

- Solution:
  #+begin_src C++ :tangle ofugsnuidai.cpp :main no :includes :results output :exports both
    #include <bits/stdc++.h>
    using namespace std;

    int main() {
      ios::sync_with_stdio(false);
      cin.tie(nullptr);

      int n;
      if (!(cin >> n)) return 0;
      vector<long long> a(n);
      for (int i = 0; i < n; ++i) cin >> a[i];
      for (int i = n - 1; i >= 0; --i) {
        cout << a[i] << '\n';
      }
      return 0;
    }
  #+end_src

- Comparison to my solution:
  | Aspect            | Your Solution                         | My Solution                           |
  |-------------------+---------------------------------------+---------------------------------------|
  | Data structure    | Raw array with ~new[]~ / ~delete[]~       | ~std::vector~ (automatic memory mgmt)   |
  | Input method      | Pointer arithmetic: ~*(arr+i)~          | Indexing: ~a[i]~                        |
  | Output format     | Numbers in reverse, space-separated   | Numbers in reverse, line-separated    |
  | Kattis acceptance | Accepted (spaces allowed)             | Accepted (matches sample exactly)     |
  | Memory management | Manual: ~delete[] arr~                  | Automatic                             |
  | Safety            | Risk of leaks/errors if not careful   | Safer, no explicit cleanup needed     |
  | Pedagogical value | Shows pointers, dynamic allocation    | Shows modern, idiomatic C++           |
  | Suitability       | Great for teaching low-level concepts | Great for quick, robust problem solve |

- Which solution is better (at a competition)?
  #+begin_quote
  Use ~std::vector~ for contests. Fewer ways to fail under time
  pressure. Cleaner to read and review.
  #+end_quote

- Contest tips:
  #+begin_quote
  Turn on fast I/O. Drop this in at the top of ~main~:
  =ios::sync_with_stdio(false); cin.tie(nullptr);= for data-heavy
  problems.

  1) The =ios= decouples C++ streams (~cin~ and ~cout~) from C streams
     (~scanf~, ~printf~). The calls don't need to coordinate anymore.

  2) =cin.tie(nullptr)= prevents unnecessary flushes: Every time you do
     ~cin~, it first flushes ~cout~. Now ~cin~ doesn't have to wait anymore.

  3) Avoid =endl= (it flushes), use ='\n'= instead.
  #+end_quote
* Easy problem 1.3 - [[https://open.kattis.com/problems/heysata][Heysata (hay-sitting)]]

- *Problem*: Search in a string =haystack= of length =n= for a character
  =k=. User input: =n=, =k=, string =haystack=.

* DONE Medium problem 3.1 - Vector Functions (Week 5 + 6)

** Problem

- Your task is to implement the following C++ functions:
  #+begin_example C++
  #include "vectorfunctions.h"

  // Reverse a vector.
  // Note that it is sent as a reference, so you should
  // reverse the same vector that was sent in.
  void backwards(vector<int>& vec){

  }

  // Return every other element of the vector, starting with the first.
  // You should return a new vector with the answer.
  // You are not allowed to modify the vector, even though it is
  // sent as a reference. Therefore, the parameter is declared "const".
  vector<int> everyOther(const vector<int>& vec){
          ...
  }

  // Return the smallest value of a vector.
  int smallest(const vector<int>& vec){
          ...
  }

  // Return the sum of the elements in the vector.
  int sum(const vector<int>& vec){
    ...
  }

  // Return the number of odd integers, that are also on an
  // odd index (with the first index being 0).
  int veryOdd(const vector<int>& vec){
    ...
  }
  #+end_example

- The vectors sent has between 1 and 100,000 elements. Each number in
  the vector is between -2000 and 2000.

- Template: You can download the above template as the file
  [[https://open.kattis.com/problems/vectorfunctions/file/statement/attachments/vectorfunctions.cpp][vectorfunctions.cpp]] in the Attachments menu. When submitting your
  solution, send in only this file.

- Testing: To test your program, you can download the file
  [[https://open.kattis.com/problems/vectorfunctions/file/statement/attachments/vectorfunctions.h][vectorfunctions.h]] in the menu to the left, which contains examples
  that test your code. Place it in the same folder as your program
  when compiling.

** Solution

*** Interface

- The problem set asks for implementation of several functions that
  have one argument, an integer ~vector~ passed as a reference (~&~):
  1) The argument vector is reversed.
  2) Every other element of the ~const~ vector is returned.
  3) The minimum element of the ~const~ vector is returned.
  4) The sum of the ~const~ vector elements is returned.
  5) The number of odd elements of the ~const~ vector that are also on
     an odd index is returned.

- To test the functions, a header file =vectorfunctions.h= is included
  in the =.cpp= file. For submission, this file contains the ~main~
  function but a better solution is to have three files:
  1. =vf.h= (for ~#include~ and function prototypes)
  2. =vf.cpp= (for function definitions)
  3. =main.cpp= (for testing)

- Include a header guard in =vf.h=:
  #+begin_src C++
    #ifndef VF_H
    #define VF_H
    // ...
    #endif
  #+end_src

- I'm going to write one function at a time as a noweb chunk, and
  tangle the chunks together later.

*** Implementation: =vf.cpp=

1) Header file:

   #+name: include header files
   #+begin_src C++
     #ifndef VF_H
     #define VF_H
     #include <iostream>
     #include <vector>
     #include <algorithm>
     #endif
   #+end_src

2) =backwards= is a ~void~ function. To reverse the parameter ~vector~ in
   place (as a reference of the ~vector~ in the calling function).

   - Plan: include ~<algorithm>~ and use the ~reverse~ function with the
     built-in iterators =vec.begin()= and =vec.end()=.

   - Function implementation:
     #+name: backwards: reverse vector
     #+begin_src C++ :main no :includes
       // Reverse a vector.
       // Note that it is sent as a reference, so you should
       // reverse the same vector that was sent in.
       void backwards(std::vector<int>& vec) // must be std::vector!
       {
         std::reverse(vec.begin(), vec.end());
       }
     #+end_src

     #+RESULTS: backwards: reverse vector

3) =everyOther= takes a constant vector reference and returns a
   vector. Plan:
   1. Define a =temp= vector.
   2. Iterate over the argument vector.
   3. Build =temp= from the iterator =*it= using ~push_back~.
   4. Return =temp=.

   Simply restrict the output data stream to every second
   element, using a range-based loop and an iterator that increments
   in twos: =it+=2=.

   - Function implementation: v1 (run-time error see below)
     #+begin_src C++ :noweb yes :main no :includes :noeval
       // Return every other element of the vector, starting with the first.
       // You should return a new vector with the answer.
       // You are not allowed to modify the vector, even though it is
       // sent as a reference. Therefore, the parameter is declared "const".
       std::vector<int> everyOther(const std::vector<int>& vec)
       {
         std::vector<int> temp;
         std::vector<int>::iterator it;
         for(auto it=vec.begin();it!=vec.end();it+=2)
           temp.push_back(*it);
         return temp;
       }
     #+end_src

   - v2: safeguard the incrementing of the iterator
     1) use ~cbegin()~ and ~cend()~, a ~const_iterator~ since =vec= is constant.
     2) By using =it < vec.cend()= I make sure that the iterator never
        steps out of bounds.

     #+name: everyOther: return every other element
     #+begin_src C++ :noweb yes :main no :includes :noeval
       // Return every other element of the vector, starting with the first.
       // You should return a new vector with the answer.
       // You are not allowed to modify the vector, even though it is
       // sent as a reference. Therefore, the parameter is declared "const".
       std::vector<int> everyOther(const std::vector<int>& vec)
       {
         std::vector<int> temp;
         std::vector<int>::iterator it;
         for(auto it = vec.cbegin();it < vec.cend();it+=2)
           temp.push_back(*it);
         return temp;
       }
     #+end_src


4) =smallest= takes a constant vector reference and returns an
   integer.

   - Plan:
     1. Define iterator
     2. Inside function, set =min= to =*vec.begin()=
     3. Range-based iterator loop over =vec= comparing =min= with each
        element and replacing it if element is smaller.
     4. Return final =min=.

   - Need to test this first with a small function:
     #+begin_src C++ :main no :includes <iostream> <vector> :results output
       // Return first vector element
       int first(const std::vector<int>& vec)
       {
         int min = *vec.begin();
         return min;
       }
       int main()
       {
         std::vector<int> test = {1, 2, 5, 3, 2, 5};
         std::cout << first(test);
         return 0;
       }
     #+end_src

     #+RESULTS:
     : 1

   - Function implementation:
     #+name: smallest: return smallest value
     #+begin_src C++ :noeval :main yes :includes
       // Return the smallest value of a vector.
       int smallest(const std::vector<int>& vec)
       {
         int min = *vec.begin();
         std::vector<int>::iterator it;
         for (auto it=vec.begin(); it!=vec.end();it++)
           if(*it<min) min=*it;
         return min;
       }
     #+end_src

5) =sum= takes a constant vector reference and returns an
   integer.

   - Plan:
     1. Set =sum= to zero.
     2. Define iterator.
     3. Loop over vector and sum up its elements =*it=.

   - Function implementation
     #+name: sum: return sum of elements
     #+begin_src C++ :noeval :main yes :includes
       // Return the sum of the vector elements
       int sum(const std::vector<int>& vec)
       {
         int sum=0;
         std::vector<int>::iterator it;
         for (auto it=vec.begin(); it!=vec.end();it++)
           sum+=*it;
         return sum;
       }
     #+end_src

6) =veryOdd= takes a constant vector reference and returns the number of
   odd integers that are also on an odd index (with the first odd
   index being =1=, since =0 % 2 == 0= or even).

   - Plan:
     1) Loop over the vector using a subscript loop (using ~.size()~)
     2) For each element, check if both the index and the element is
        odd: ~(i % 2 !== 0) && (vec[i] % 2 != 0)~
     3) Return the counter of these elements.

   - Function implementation:
     #+name: veryOdd: return number of odd integers on an odd index
     #+begin_src C++ :noeval :main yes :includes
       // Return the number of odd integers, that are also on an
       // odd index (with the first index being 0).
       int veryOdd(const std::vector<int>& vec)
       {
         int counter = 0;
         for (int i = 0; i < vec.size(); i++)
           if ( (i % 2 != 0) && (vec[i] % 2 != 0)) counter++;
         return counter;
       }
     #+end_src

*** Testing: =main.cpp=

- The ~main~ program with the tests from =vectorfunctions.h=:

  #+begin_src C++ :main no :includes :noweb yes :tangle ../src/main.cpp :noeval
    <<include header files>>
    <<backwards: reverse vector>>
    <<everyOther: return every other element>>
    <<smallest: return smallest value>>
    <<sum: return sum of elements>>
    <<veryOdd: return number of odd integers on an odd index>>

    int main()
      {
        std::vector<int> test = {1, 2, 5, 3, 2, 5};
        std::vector<int> expected = {5, 2, 3, 5, 2, 1};

        // backwards: reverse vector in place
        backwards(test); // changes `test` vector in place
        if (test != expected) {
          std::cerr << "backwards() was incorrect" << std::endl;
          exit(1);
        }

        // everyOther: return every other element
        test = {1, 2, 5, 3, 2, 5};
        expected = {1, 5, 2};
        std::vector<int> got = everyOther(test);
        if (got != expected) {
          std::cerr << "everyOther() was incorrect" << std::endl;
          exit(1);
        }

        // smallest: return smallest value
        test = {1, 2, 5, 3, 2, 5};
        int ans = smallest(test);
        if (ans != 1) {
          std::cerr << "smallest() was incorrect" << std::endl;
          exit(1);
        }

        // sum: return sum of elements
        test = {1, 2, 5, 3, 2, 5};
        ans = sum(test);
        if (ans != 1+2+5+3+2+5) {
          std::cerr << "sum() was incorrect" << std::endl;
          exit(1);
        }

        // veryOdd: return number of odd integers on an odd index
        test = {1, 2, 5, 3, 2, 5};
        ans = veryOdd(test);
        if (ans != 2) {
          std::cerr << "veryOdd() was incorrect" << std::endl;
          exit(1);
        }
        // all tests passed
        std::cerr << "OK!" << std::endl;

        return 0;
      }
  #+end_src

- Testing on the command-line: No output means tests passed.
  #+begin_src bash :results output :exports both
    cd ../src
    make main
    ./main
  #+end_src

  #+RESULTS:
  : g++     main.cpp   -o main

*** TODO Submission to open.kattis.com

- Files and Makefile: I'm instructed to only submit
  =vectorfunctions.cpp= using the template. The included file
  =vectorfunctions.h= takes care of the rest: it contains the ~#include~
  files as well as the prototypes and the ~main~ program with the tests.

- For Emacs Org-mode, add =:flags -I ../src/= which is where the header
  file is located. I call the tangled file =vectorfunctions2.cpp= to
  preserve the template.

- Copying the ~noweb~ chunks to get the function definitions. So now the
  tangled file looks like this:
  1) included header files
  2) function prototypes
  3) main function with tests
  4) function definitions.

- Didn't need a makefile after all.

- Final implementation of =vectorfunctions2.cpp= for submission:
  #+begin_src C++ :results none :noweb yes :flags -I "../src/" :includes :main no :tangle ../src/vectorfunctions2.cpp
    #include "vectorfunctions.h"
    <<backwards: reverse vector>>
    <<everyOther: return every other element>>
    <<smallest: return smallest value>>
    <<sum: return sum of elements>>
    <<veryOdd: return number of odd integers on an odd index>>
  #+end_src

- Notice that the output "OK!" is written to ~cerr~ and not to ~cout~.

- Submission test:
  1) v1 failed with compile-time error (see below) - include ~<algorithm>~
  2) v2 failed with run-time error (see below) - out of bounds iterator
  3) v3 succeeded: https://open.kattis.com/submissions/18380989

  #+begin_example C++
  #include "vectorfunctions.h"
  #include <algorithm>
  // Reverse a vector.
  // Note that it is sent as a reference, so you should
  // reverse the same vector that was sent in.
  void backwards(std::vector<int>& vec) // must be std::vector!
  {
    std::reverse(vec.begin(), vec.end());
  }
  // Return every other element of the vector, starting with the first.
  // You should return a new vector with the answer.
  // You are not allowed to modify the vector, even though it is
  // sent as a reference. Therefore, the parameter is declared "const".
  std::vector<int> everyOther(const std::vector<int>& vec)
  {
    std::vector<int> temp;
    std::vector<int>::iterator it;
    for(auto it = vec.cbegin();it < vec.cend();it+=2)
      temp.push_back(*it);
    return temp;
  }
  // Return the smallest value of a vector.
  int smallest(const std::vector<int>& vec)
  {
    int min = *vec.begin();
    std::vector<int>::iterator it;
    for (auto it=vec.begin(); it!=vec.end();it++)
      if(*it<min) min=*it;
    return min;
  }
  // Return the sum of the vector elements
  int sum(const std::vector<int>& vec)
  {
    int sum=0;
    std::vector<int>::iterator it;
    for (auto it=vec.begin(); it!=vec.end();it++)
      sum+=*it;
    return sum;
  }
  // Return the number of odd integers, that are also on an
  // odd index (with the first index being 0).
  int veryOdd(const std::vector<int>& vec)
  {
    int counter = 0;
    for (int i = 0; i < vec.size(); i++)
      if ( (i % 2 != 0) && (vec[i] % 2 != 0)) counter++;
    return counter;
  }
  #+end_example

*** Extensions and explanations

**** Errors

- Note: Weird error message.
  #+begin_example
  main.cpp:6:6: error: variable or field â€˜backwardsâ€™ declared void
      6 | void backwards(vector<int>& vec)
        |      ^~~~~~~~~
  main.cpp:6:16: error: â€˜vectorâ€™ was not declared in this scope
      6 | void backwards(vector<int>& vec)
        |                ^~~~~~
  #+end_example

  Explanation: I had forgotten to =std::= to the =vector= parameter in the
  =backwards= definition!

- First submission failed:
  #+begin_example
  /src/vectorfunctions.cpp: In function â€˜void backwards(std::vector<int>&)â€™:
  /src/vectorfunctions.cpp:7:8: error: â€˜reverseâ€™ is not a member of â€˜stdâ€™
      7 |   std::reverse(vec.begin(), vec.end());
        |        ^~~~~~~
  Exited with error status 1
  #+end_example

  Not sure I understand that since ~reverse~ is in the ~std~ namespace
  according to the definition in cppreference.com (from
  ~<algorithm>~. And why would it work for me and not on kattis?

- In any case, adding ~#include <algorithm~ at the head of the file does
  the trick. But now I get a runtime error. This is due to =everyOther=:
  The increment =it+=2= is dangerous and needs to be checked because
  =vec.end()= points actually beyond the end of the vector. Build in a
  safe guard.

**** Extensions

- Before working with ~reverse~ in =backwards=, I had written this function:

- The question: What if I don't have ~reverse~, how can I save the
  reversed vector and return it?
* [[https://open.kattis.com/problems/averagecharacter][Average Character (Easy 2.0]])

** Problem

Given a string of ASCII characters, compute the average character. If
the average character lies between two integer ASCII values, return
the smaller one.

** Input 

- Enter a single non-empty string on one line, max. 100 characters.
- Sample input/output:
  | ABCDE | C |
  | AbCdE | O |
  | aBcDe | V |

** Constraints

- All characters must be printable ASCII characters between 32 (' ')
  and 126 (~).
- No control characters such as carriage returns, line feeds, tabs
  etc.
- The string can begin, end, or contain only spaces.

** Solution

- Let's begin by checking the sample input/output with a simple
  program that converts the string to ASCII numbers, computes the
  average, and converts this number back to an ASCII character.

  #+name: v1
  #+begin_src C++ :main yes :includes <iostream> <cstdlib> <string> <fstream> <vector> :namespaces std :results output :exports both :noweb yes
    std::string s = "aBcDe"; // ABCD:C, AbCdE:O, aBcDe:V
    int sum=0;
    for (int i=0; i<s.size();i++)
      {
        int s_i = static_cast<int>(s[i]);
        cout << s[i] << " " // print string by character
    	 << s_i << endl; // print ASCII number
        sum += s_i;
      }
    double avg = sum/s.size();
    cout << "Average ASCII number: "     << avg << endl
    << "Average ASCII character: "  << static_cast<char>(avg);
  #+end_src

  #+RESULTS: v1
  : a 97
  : B 66
  : c 99
  : D 68
  : e 101
  : Average ASCII number: 86
  : Average ASCII character: V

- This little program solves the three sample cases but it fails
  whenever there is one or more empty space (ASCII 32) present. The
  simplest solution for now: exclude these characters and rebuild the
  string without empty spaces.

  #+name: v2
  #+begin_src C++ :main yes :includes <iostream> <cstdlib> <string> <fstream> <vector> :namespaces std :results output :exports both :noweb yes
    std::string s = " AB  CDE"; // ABCD:C, AbCdE:O, aBcDe:V
    int sum=0;
    int SIZE = s.size();
    for (int i=0; i<s.size();i++)
      {
        int s_i = static_cast<int>(s[i]);
        if (s_i != 32)
          {
    	cout << s[i] << " " // print string by character
    	     << s_i << endl; // print ASCII number
    	sum += s_i;
          }
        else
          {
    	SIZE--;
          }
      }
    double avg = sum/SIZE;
    cout << "Average ASCII number: "     << avg << endl
    << "Average ASCII character: "  << static_cast<char>(avg);
      #+end_src

      #+RESULTS: v2
      : A 65
      : B 66
      : C 67
      : D 68
      : E 69
      : Average ASCII number: 67
      : Average ASCII character: C

- Now add the ability to get line input with ~getline~:
  
  #+name: v3
  #+begin_src C++ :tangle ../src/averagecharacter.cpp :main yes :includes <iostream> <cstdlib> <string> <fstream> <vector> :namespaces std :results output :exports both :noweb yes
    std::string s;
    getline(cin, s);
    int sum=0;
    int SIZE = s.size();
    for (int i=0; i<s.size();i++)
      {
        int s_i = static_cast<int>(s[i]);
        if (s_i != 32)
          {
    	cout << s[i] << " " // print string by character
    	     << s_i << endl; // print ASCII number
    	sum += s_i;
          }
        else
          {
    	SIZE--;
          }
      }
    double avg = sum/SIZE;
    cout << "Average ASCII number: "     << avg << endl
    << "Average ASCII character: "  << static_cast<char>(avg);
      #+end_src

- Testing:
  #+begin_src bash :results output :exports both
    cd ../src
    make averagecharacter
    echo " AB CDE" | ./averagecharacter
  #+end_src

  #+RESULTS:
  : make: 'averagecharacter' is up to date.
  : A 65
  : B 66
  : C 67
  : D 68
  : E 69
  : Average ASCII number: 67
  : Average ASCII character: C

- Submission with full header:
  #+name: v4
  #+begin_src C++ :results output :main no :includes :cmdline < ../data/input
    #include <iostream>
    #include <string>

    int main()
    {
      std::string s;
      getline(std::cin, s);
      int sum=0;
      int SIZE = s.size();
      for (int i=0; i<s.size();i++)
        {
          int s_i = static_cast<int>(s[i]);
          if (s_i != 32)
    	{
    	  sum += s_i;
    	}
          else
    	{
    	  SIZE--;
    	}
        }
      double avg = sum/SIZE;
      std::cout << static_cast<char>(avg);
      return 0;
    }
  #+end_src  

  #+RESULTS:
  : C

  Input file:
  #+begin_src bash :results output :exports both
    cd ../data
    echo "ABCDE" > input
    cat input
  #+end_src

  #+RESULTS:
  : ABCDE
  
- Fails at the fifth test case with a run-time error: probably because
  one of the strings results in a non-ASCII average. The lower of the
  two neighbouring ASCII characters has to be chosen.

- Realized that the integer division floors automatically - it rounds
  down towards the smaller integer: 65/2 becomes 32 etc. This version
  passes on Kattis:

  #+name: https://open.kattis.com/submissions/18449281
  #+begin_src C++ :results output :main no :includes :cmdline < ../data/input
    #include <string>
    int main()
    {
      std::string s;
      std::getline(std::cin, s);
      long sum = 0;
      for (char c : s)
        sum += static_cast<unsigned char>(c);
      if (!s.empty())
        {
          int avg = sum / s.size(); // integer division floors automatically
          std::cout << static_cast<char>(avg) << '\n';
        }
      return 0;
    }
  #+end_src  

- What I learnt:
  1) Use of ~static_cast~ with memory savings (~<unsigned char>~)
  2) Integer division floors automatically.
  3) Elegant use of range-based loops
  
  
  
